<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>knncolle: knncolle Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">knncolle
   </div>
   <div id="projectbrief">Collection of KNN methods in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">knncolle Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collection of KNN algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1BruteforceBuilder.html">BruteforceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a brute-force nearest neighbor search.  <a href="classknncolle_1_1BruteforceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to build nearest-neighbor search indices.  <a href="classknncolle_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1DistanceMetric.html">DistanceMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a distance metric.  <a href="classknncolle_1_1DistanceMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1EuclideanDistance.html">EuclideanDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euclidean distances between two input vectors.  <a href="classknncolle_1_1EuclideanDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1L2NormalizedBuilder.html">L2NormalizedBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a builder with L2 normalization.  <a href="classknncolle_1_1L2NormalizedBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1L2NormalizedMatrix.html">L2NormalizedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a matrix with L2 normalization.  <a href="classknncolle_1_1L2NormalizedMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structknncolle_1_1L2NormalizedPrebuiltTypes.html">L2NormalizedPrebuiltTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type of a saved L2-normalized index.  <a href="structknncolle_1_1L2NormalizedPrebuiltTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1LoadDistanceMetricNotFoundError.html">LoadDistanceMetricNotFoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for unknown distance metrics in <code><a class="el" href="#acd94b11fc8a2fade908a509ed2ecfddb">load_distance_metric_raw()</a></code>.  <a href="classknncolle_1_1LoadDistanceMetricNotFoundError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1LoadPrebuiltNotFoundError.html">LoadPrebuiltNotFoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for unknown search algorithms in <code><a class="el" href="#a2157dec9e895be903278fc6903c793e0">load_prebuilt_raw()</a></code>.  <a href="classknncolle_1_1LoadPrebuiltNotFoundError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1ManhattanDistance.html">ManhattanDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Manhattan distances between two input vectors.  <a href="classknncolle_1_1ManhattanDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for matrix data.  <a href="classknncolle_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1MatrixExtractor.html">MatrixExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extractor interface for matrix data.  <a href="classknncolle_1_1MatrixExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1NeighborQueue.html">NeighborQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to track nearest neighbors.  <a href="classknncolle_1_1NeighborQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for prebuilt nearest-neighbor search indices.  <a href="classknncolle_1_1Prebuilt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Searcher.html">Searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for searching nearest-neighbor search indices.  <a href="classknncolle_1_1Searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1SimpleMatrix.html">SimpleMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for an in-memory matrix.  <a href="classknncolle_1_1SimpleMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1VptreeBuilder.html">VptreeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a nearest neighbor search based on a vantage point (VP) tree.  <a href="classknncolle_1_1VptreeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a67fb4089867eeafca50930f79698f820" id="r_a67fb4089867eeafca50930f79698f820"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a67fb4089867eeafca50930f79698f820"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67fb4089867eeafca50930f79698f820">LoadDistanceMetricFunction</a> = std::function&lt;<a class="el" href="classknncolle_1_1DistanceMetric.html">DistanceMetric</a>&lt;Data_, Distance_&gt;* (const std::filesystem::path&amp;)&gt;</td></tr>
<tr class="separator:a67fb4089867eeafca50930f79698f820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97693d779b6041859ffa0ef2d9c1500b" id="r_a97693d779b6041859ffa0ef2d9c1500b"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a97693d779b6041859ffa0ef2d9c1500b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97693d779b6041859ffa0ef2d9c1500b">NeighborList</a> = std::vector&lt;std::vector&lt;std::pair&lt;Index_, Distance_&gt; &gt; &gt;</td></tr>
<tr class="separator:a97693d779b6041859ffa0ef2d9c1500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0574e57c9150cb0bfe1da0e7eff6aa01" id="r_a0574e57c9150cb0bfe1da0e7eff6aa01"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a0574e57c9150cb0bfe1da0e7eff6aa01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0574e57c9150cb0bfe1da0e7eff6aa01">LoadPrebuiltFunction</a> = std::function&lt;<a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt;Index_, Data_, Distance_&gt;* (const std::filesystem::path&amp;)&gt;</td></tr>
<tr class="separator:a0574e57c9150cb0bfe1da0e7eff6aa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9aa73a4ad540791a911eb9fa64b51de3" id="r_a9aa73a4ad540791a911eb9fa64b51de3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa73a4ad540791a911eb9fa64b51de3">NumericType</a> : char { <br />
&#160;&#160;<b>UINT8_T</b>
, <b>INT8_T</b>
, <b>UINT16_T</b>
, <b>INT16_T</b>
, <br />
&#160;&#160;<b>UINT32_T</b>
, <b>INT32_T</b>
, <b>UINT64_T</b>
, <b>INT64_T</b>
, <br />
&#160;&#160;<b>UNSIGNED_CHAR</b>
, <b>SIGNED_CHAR</b>
, <b>CHAR</b>
, <b>UNSIGNED_SHORT</b>
, <br />
&#160;&#160;<b>SHORT</b>
, <b>UNSIGNED_INT</b>
, <b>INT</b>
, <b>UNSIGNED_LONG</b>
, <br />
&#160;&#160;<b>LONG</b>
, <b>UNSIGNED_LONG_LONG</b>
, <b>LONG_LONG</b>
, <b>SIZE_T</b>
, <br />
&#160;&#160;<b>PTRDIFF_T</b>
, <b>FLOAT</b>
, <b>DOUBLE</b>
, <b>UNKNOWN</b>
<br />
 }</td></tr>
<tr class="separator:a9aa73a4ad540791a911eb9fa64b51de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad4af1d9292bd24d4bd3f72f4f99d9cbc" id="r_ad4af1d9292bd24d4bd3f72f4f99d9cbc"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:ad4af1d9292bd24d4bd3f72f4f99d9cbc"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="#a67fb4089867eeafca50930f79698f820">LoadDistanceMetricFunction</a>&lt; Data_, Distance_ &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4af1d9292bd24d4bd3f72f4f99d9cbc">load_distance_metric_registry</a> ()</td></tr>
<tr class="separator:ad4af1d9292bd24d4bd3f72f4f99d9cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ca6694c66f6c7107baffb3b8614d2e" id="r_a72ca6694c66f6c7107baffb3b8614d2e"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a72ca6694c66f6c7107baffb3b8614d2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72ca6694c66f6c7107baffb3b8614d2e">register_load_euclidean_distance</a> ()</td></tr>
<tr class="separator:a72ca6694c66f6c7107baffb3b8614d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e446385ed1746050c0bd2450a8e7298" id="r_a9e446385ed1746050c0bd2450a8e7298"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a9e446385ed1746050c0bd2450a8e7298"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e446385ed1746050c0bd2450a8e7298">register_load_manhattan_distance</a> ()</td></tr>
<tr class="separator:a9e446385ed1746050c0bd2450a8e7298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd94b11fc8a2fade908a509ed2ecfddb" id="r_acd94b11fc8a2fade908a509ed2ecfddb"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:acd94b11fc8a2fade908a509ed2ecfddb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classknncolle_1_1DistanceMetric.html">DistanceMetric</a>&lt; Data_, Distance_ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd94b11fc8a2fade908a509ed2ecfddb">load_distance_metric_raw</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:acd94b11fc8a2fade908a509ed2ecfddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf80c12bbfbab853c41f6d001fe073" id="r_a5faf80c12bbfbab853c41f6d001fe073"><td class="memTemplParams" colspan="2">template&lt;typename Task_ , class Run_ &gt; </td></tr>
<tr class="memitem:a5faf80c12bbfbab853c41f6d001fe073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5faf80c12bbfbab853c41f6d001fe073">parallelize</a> (int num_workers, Task_ num_tasks, Run_ run_task_range)</td></tr>
<tr class="separator:a5faf80c12bbfbab853c41f6d001fe073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c81cd626de7081b073a891d352543" id="r_a926c81cd626de7081b073a891d352543"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:a926c81cd626de7081b073a891d352543"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a926c81cd626de7081b073a891d352543">cap_k</a> (int k, Index_ num_observations)</td></tr>
<tr class="separator:a926c81cd626de7081b073a891d352543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918d96e82ead9e67d7c008bde1e22505" id="r_a918d96e82ead9e67d7c008bde1e22505"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:a918d96e82ead9e67d7c008bde1e22505"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a918d96e82ead9e67d7c008bde1e22505">cap_k_query</a> (int k, Index_ num_observations)</td></tr>
<tr class="separator:a918d96e82ead9e67d7c008bde1e22505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d8b116464bab254bda34216338c3c" id="r_a2c6d8b116464bab254bda34216338c3c"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a2c6d8b116464bab254bda34216338c3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a97693d779b6041859ffa0ef2d9c1500b">NeighborList</a>&lt; Index_, Distance_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c6d8b116464bab254bda34216338c3c">find_nearest_neighbors</a> (const <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &amp;index, int k, int num_threads=1)</td></tr>
<tr class="separator:a2c6d8b116464bab254bda34216338c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406dfe7aac78dee986262a5f6bceee7" id="r_a8406dfe7aac78dee986262a5f6bceee7"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a8406dfe7aac78dee986262a5f6bceee7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8406dfe7aac78dee986262a5f6bceee7">find_nearest_neighbors_index_only</a> (const <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &amp;index, int k, int num_threads=1)</td></tr>
<tr class="separator:a8406dfe7aac78dee986262a5f6bceee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf5942d7b462be001619860d8b4b158" id="r_addf5942d7b462be001619860d8b4b158"><td class="memTemplParams" colspan="2">template&lt;typename Normalized_ &gt; </td></tr>
<tr class="memitem:addf5942d7b462be001619860d8b4b158"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const std::filesystem::path &amp;)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addf5942d7b462be001619860d8b4b158">custom_save_for_l2normalized_normalized</a> ()</td></tr>
<tr class="separator:addf5942d7b462be001619860d8b4b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08de1eb1a23d5e13dc11e23ad7967ea" id="r_aa08de1eb1a23d5e13dc11e23ad7967ea"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:aa08de1eb1a23d5e13dc11e23ad7967ea"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="#a0574e57c9150cb0bfe1da0e7eff6aa01">LoadPrebuiltFunction</a>&lt; Index_, Data_, Distance_ &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa08de1eb1a23d5e13dc11e23ad7967ea">load_prebuilt_registry</a> ()</td></tr>
<tr class="separator:aa08de1eb1a23d5e13dc11e23ad7967ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2157dec9e895be903278fc6903c793e0" id="r_a2157dec9e895be903278fc6903c793e0"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a2157dec9e895be903278fc6903c793e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2157dec9e895be903278fc6903c793e0">load_prebuilt_raw</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a2157dec9e895be903278fc6903c793e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4f999cb4b25dd5bd4595bfb680f10" id="r_a9cb4f999cb4b25dd5bd4595bfb680f10"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a9cb4f999cb4b25dd5bd4595bfb680f10"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cb4f999cb4b25dd5bd4595bfb680f10">load_prebuilt_unique</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a9cb4f999cb4b25dd5bd4595bfb680f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0958bf13fd4ad18e0fa0d35d9bd47665" id="r_a0958bf13fd4ad18e0fa0d35d9bd47665"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a0958bf13fd4ad18e0fa0d35d9bd47665"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0958bf13fd4ad18e0fa0d35d9bd47665">load_prebuilt_shared</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a0958bf13fd4ad18e0fa0d35d9bd47665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226ddc157c8e3c39d89b13bb412dda4" id="r_a7226ddc157c8e3c39d89b13bb412dda4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structknncolle_1_1L2NormalizedPrebuiltTypes.html">L2NormalizedPrebuiltTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7226ddc157c8e3c39d89b13bb412dda4">load_l2normalized_prebuilt_types</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a7226ddc157c8e3c39d89b13bb412dda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a79aea2d2c0a9ece9e107c60776c22" id="r_a54a79aea2d2c0a9ece9e107c60776c22"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ , typename Normalized_ &gt; </td></tr>
<tr class="memitem:a54a79aea2d2c0a9ece9e107c60776c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54a79aea2d2c0a9ece9e107c60776c22">load_l2normalized_prebuilt</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a54a79aea2d2c0a9ece9e107c60776c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061dcb25d3ba45a3f171123eed099cb9" id="r_a061dcb25d3ba45a3f171123eed099cb9"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ , class DistanceMetric_  = DistanceMetric&lt;Data_, Distance_&gt;&gt; </td></tr>
<tr class="memitem:a061dcb25d3ba45a3f171123eed099cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a061dcb25d3ba45a3f171123eed099cb9">load_bruteforce_prebuilt</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a061dcb25d3ba45a3f171123eed099cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fe941ede848705fba1c15da9cf772a" id="r_a68fe941ede848705fba1c15da9cf772a"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ , class DistanceMetric_  = DistanceMetric&lt;Data_, Distance_&gt;&gt; </td></tr>
<tr class="memitem:a68fe941ede848705fba1c15da9cf772a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68fe941ede848705fba1c15da9cf772a">load_vptree_prebuilt</a> (const std::filesystem::path &amp;dir)</td></tr>
<tr class="separator:a68fe941ede848705fba1c15da9cf772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e640363d9246c58008c93166021f26" id="r_a84e640363d9246c58008c93166021f26"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a84e640363d9246c58008c93166021f26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a9aa73a4ad540791a911eb9fa64b51de3">NumericType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84e640363d9246c58008c93166021f26">get_numeric_type</a> ()</td></tr>
<tr class="separator:a84e640363d9246c58008c93166021f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab636bced615a3a669ef0e207b5d848cc" id="r_ab636bced615a3a669ef0e207b5d848cc"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:ab636bced615a3a669ef0e207b5d848cc"><td class="memTemplItemLeft" align="right" valign="top">Index_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab636bced615a3a669ef0e207b5d848cc">count_all_neighbors_without_self</a> (Index_ count)</td></tr>
<tr class="separator:ab636bced615a3a669ef0e207b5d848cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a311775039654985b447c85d03782" id="r_af24a311775039654985b447c85d03782"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ , typename Index_ &gt; </td></tr>
<tr class="memitem:af24a311775039654985b447c85d03782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af24a311775039654985b447c85d03782">report_all_neighbors</a> (std::vector&lt; std::pair&lt; Distance_, Index_ &gt; &gt; &amp;all_neighbors, std::vector&lt; Index_ &gt; *output_indices, std::vector&lt; Distance_ &gt; *output_distances, Index_ self)</td></tr>
<tr class="separator:af24a311775039654985b447c85d03782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42206db56aa02366c741249e609465c" id="r_ab42206db56aa02366c741249e609465c"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab42206db56aa02366c741249e609465c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab42206db56aa02366c741249e609465c">report_all_neighbors</a> (std::vector&lt; std::pair&lt; Distance_, Index_ &gt; &gt; &amp;all_neighbors, std::vector&lt; Index_ &gt; *output_indices, std::vector&lt; Distance_ &gt; *output_distances)</td></tr>
<tr class="separator:ab42206db56aa02366c741249e609465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf69c31b24c8a2bda72371f64133f8b8" id="r_acf69c31b24c8a2bda72371f64133f8b8"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Length_ &gt; </td></tr>
<tr class="memitem:acf69c31b24c8a2bda72371f64133f8b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf69c31b24c8a2bda72371f64133f8b8">quick_save</a> (const std::filesystem::path &amp;path, const Input_ *const contents, const Length_ length)</td></tr>
<tr class="separator:acf69c31b24c8a2bda72371f64133f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e25b966ec80b5ab45dced14fe690e6b" id="r_a1e25b966ec80b5ab45dced14fe690e6b"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Length_ &gt; </td></tr>
<tr class="memitem:a1e25b966ec80b5ab45dced14fe690e6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e25b966ec80b5ab45dced14fe690e6b">quick_load</a> (const std::filesystem::path &amp;path, Input_ *const contents, const Length_ length)</td></tr>
<tr class="separator:a1e25b966ec80b5ab45dced14fe690e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191267167f1e0d7201b276c8a9caa2a" id="r_a9191267167f1e0d7201b276c8a9caa2a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9191267167f1e0d7201b276c8a9caa2a">quick_load_as_string</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a9191267167f1e0d7201b276c8a9caa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of KNN algorithms. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a67fb4089867eeafca50930f79698f820" name="a67fb4089867eeafca50930f79698f820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fb4089867eeafca50930f79698f820">&#9670;&#160;</a></span>LoadDistanceMetricFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a67fb4089867eeafca50930f79698f820">knncolle::LoadDistanceMetricFunction</a> = std::function&lt;<a class="el" href="classknncolle_1_1DistanceMetric.html">DistanceMetric</a>&lt;Data_, Distance_&gt;* (const std::filesystem::path&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distance loading function. This accepts a path to a directory (see <code><a class="el" href="classknncolle_1_1DistanceMetric.html#aa2989e7df3cb8e65d161629473914d55">DistanceMetric::save()</a></code>) and returns a pointer to a <code>Distance</code> instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the output distance, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0574e57c9150cb0bfe1da0e7eff6aa01" name="a0574e57c9150cb0bfe1da0e7eff6aa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0574e57c9150cb0bfe1da0e7eff6aa01">&#9670;&#160;</a></span>LoadPrebuiltFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0574e57c9150cb0bfe1da0e7eff6aa01">knncolle::LoadPrebuiltFunction</a> = std::function&lt;<a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt;Index_, Data_, Distance_&gt;* (const std::filesystem::path&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a> loading function. This accepts a directory (see <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>) and returns a pointer to a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97693d779b6041859ffa0ef2d9c1500b" name="a97693d779b6041859ffa0ef2d9c1500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97693d779b6041859ffa0ef2d9c1500b">&#9670;&#160;</a></span>NeighborList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a97693d779b6041859ffa0ef2d9c1500b">knncolle::NeighborList</a> = std::vector&lt;std::vector&lt;std::pair&lt;Index_, Distance_&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of nearest neighbors for multiple observations. Each entry corresponds to an observation and contains a nested list (i.e., vector) of its neighbors. Each entry of the nested vector is a pair that contains the identity of the neighbor as an observation index (first) and the distance from the observation to the neighbor (second), sorted by increasing distance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9aa73a4ad540791a911eb9fa64b51de3" name="a9aa73a4ad540791a911eb9fa64b51de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa73a4ad540791a911eb9fa64b51de3">&#9670;&#160;</a></span>NumericType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9aa73a4ad540791a911eb9fa64b51de3">knncolle::NumericType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Standard numeric types, typically returned by <code><a class="el" href="#a84e640363d9246c58008c93166021f26">get_numeric_type()</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a926c81cd626de7081b073a891d352543" name="a926c81cd626de7081b073a891d352543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926c81cd626de7081b073a891d352543">&#9670;&#160;</a></span>cap_k()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int knncolle::cap_k </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num_observations</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cap the number of neighbors to use in <code><a class="el" href="classknncolle_1_1Searcher.html#ab0f6c2ce78952dd555f7f1a8fb3ac208">Searcher::search()</a></code> with an index <code>i</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the number of observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of nearest neighbors, should be non-negative. </td></tr>
    <tr><td class="paramname">num_observations</td><td>Number of observations in the dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Capped number of neighbors to search for. This is equal to <code>k</code> if it is less than <code>num_observations</code>; otherwise it is equal to <code>num_observations - 1</code> if <code>num_observations &gt; 0</code>; otherwise it is equal to zero. </dd></dl>

</div>
</div>
<a id="a918d96e82ead9e67d7c008bde1e22505" name="a918d96e82ead9e67d7c008bde1e22505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918d96e82ead9e67d7c008bde1e22505">&#9670;&#160;</a></span>cap_k_query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int knncolle::cap_k_query </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num_observations</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cap the number of neighbors to use in <code><a class="el" href="classknncolle_1_1Searcher.html#ab0f6c2ce78952dd555f7f1a8fb3ac208">Searcher::search()</a></code> with a pointer <code>query</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the number of observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of nearest neighbors, should be non-negative. </td></tr>
    <tr><td class="paramname">num_observations</td><td>Number of observations in the dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Capped number of neighbors to query. This is equal to the smaller of <code>k</code> and <code>num_observations</code>. </dd></dl>

</div>
</div>
<a id="ab636bced615a3a669ef0e207b5d848cc" name="ab636bced615a3a669ef0e207b5d848cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab636bced615a3a669ef0e207b5d848cc">&#9670;&#160;</a></span>count_all_neighbors_without_self()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Index_ knncolle::count_all_neighbors_without_self </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of neighbors from a range-based search, after removing the observation being searched. This is intended for developer use in implementations of <code><a class="el" href="classknncolle_1_1Searcher.html#a3ef8c1bf087751bff46af346bda2feb3">Searcher::search_all()</a></code>, and protects against pathological situations where an observation fails to be detected as its own neighbor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of neighbors within range of the specified observation, including the observation itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>count - 1</code> in most cases, otherwise zero. </dd></dl>

</div>
</div>
<a id="addf5942d7b462be001619860d8b4b158" name="addf5942d7b462be001619860d8b4b158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf5942d7b462be001619860d8b4b158">&#9670;&#160;</a></span>custom_save_for_l2normalized_normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Normalized_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(const std::filesystem::path &amp;)&gt; &amp; knncolle::custom_save_for_l2normalized_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to preserve <code>Normalized_</code> type information when saving a prebuilt L2-normalized index in <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>. Users should define their own function here to handle an <code>Normalized_</code> type that is unknown to <code><a class="el" href="#a84e640363d9246c58008c93166021f26">get_numeric_type()</a></code>. The action of setting/unsetting the global function is not thread-safe and should be done in a serial section.</p>
<p>The sole argument of the global function is the same <code>dir</code> provided to <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>. If a global function is provided, it is generally expected to write information about <code>Normalized_</code> to files inside <code>dir</code>. It is recommended that the names of these files should not start with upper-case letters to avoid conflicts with files generated by <code>save()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Normalized_</td><td>Floating-point type for the L2-normalized data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for saving information about <code>Normalized_</code>. By default, no global function is defined. If set, the global function will be called by the <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> method for the L2-normalized <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> subclass. </dd></dl>

</div>
</div>
<a id="a2c6d8b116464bab254bda34216338c3c" name="a2c6d8b116464bab254bda34216338c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6d8b116464bab254bda34216338c3c">&#9670;&#160;</a></span>find_nearest_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a97693d779b6041859ffa0ef2d9c1500b">NeighborList</a>&lt; Index_, Distance_ &gt; knncolle::find_nearest_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest neighbors within a pre-built index. This is a convenient wrapper around <code><a class="el" href="classknncolle_1_1Searcher.html#ab0f6c2ce78952dd555f7f1a8fb3ac208">Searcher::search</a></code> that saves the caller the trouble of writing a loop.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> index. </td></tr>
    <tr><td class="paramname">k</td><td>Number of nearest neighbors. This should be non-negative. Explicitly calling <code><a class="el" href="#a926c81cd626de7081b073a891d352543">cap_k()</a></code> is not necessary as this is done automatically inside this function. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. The parallelization scheme is defined by <code><a class="el" href="#a5faf80c12bbfbab853c41f6d001fe073">parallelize()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>NeighborList</code> of length equal to the number of observations in <code>index</code>. Each entry contains (up to) the <code>k</code> nearest neighbors for each observation, sorted by increasing distance. The <code>i</code>-th entry is guaranteed to not contain <code>i</code> itself. </dd></dl>

</div>
</div>
<a id="a8406dfe7aac78dee986262a5f6bceee7" name="a8406dfe7aac78dee986262a5f6bceee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8406dfe7aac78dee986262a5f6bceee7">&#9670;&#160;</a></span>find_nearest_neighbors_index_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Index_ &gt; &gt; knncolle::find_nearest_neighbors_index_only </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest neighbors within a pre-built search index. Here, only the neighbor indices are returned, not the distances.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the input and query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> index. </td></tr>
    <tr><td class="paramname">k</td><td>Number of nearest neighbors. This should be non-negative. Explicitly calling <code><a class="el" href="#a926c81cd626de7081b073a891d352543">cap_k()</a></code> is not necessary as this is done automatically inside this function. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. The parallelization scheme is defined by <code><a class="el" href="#a5faf80c12bbfbab853c41f6d001fe073">parallelize()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of length equal to the number of observations in <code>index</code>. Each vector contains the indices of (up to) the <code>k</code> nearest neighbors for each observation, sorted by increasing distance. The <code>i</code>-th entry is guaranteed to not contain <code>i</code> itself. </dd></dl>

</div>
</div>
<a id="a84e640363d9246c58008c93166021f26" name="a84e640363d9246c58008c93166021f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e640363d9246c58008c93166021f26">&#9670;&#160;</a></span>get_numeric_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9aa73a4ad540791a911eb9fa64b51de3">NumericType</a> knncolle::get_numeric_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type_</td><td>Some integer or floating-point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identity of the numeric type.</dd></dl>
<p>This function is intended for developers writing their own <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> methods, where a subclass may have additional template types beyond those required by the <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> template. In such cases, developers can convert the type into a <code>NumericType</code> that can be saved to disk. The corresponding loader function can then read this type information to accurately reconstitute the original <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> object. </p>

</div>
</div>
<a id="a061dcb25d3ba45a3f171123eed099cb9" name="a061dcb25d3ba45a3f171123eed099cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061dcb25d3ba45a3f171123eed099cb9">&#9670;&#160;</a></span>load_bruteforce_prebuilt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ , class DistanceMetric_  = DistanceMetric&lt;Data_, Distance_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; * knncolle::load_bruteforce_prebuilt </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an brute-force search index (i.e., a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> created by <code><a class="el" href="classknncolle_1_1BruteforceBuilder.html" title="Perform a brute-force nearest neighbor search.">BruteforceBuilder</a></code>) from its on-disk representation. This is not provided in the registry by default as its depends on the application's choice of <code>DistanceMetric_</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">DistanceMetric_</td><td>Class implementing the distance metric calculation. This should satisfy the <code><a class="el" href="classknncolle_1_1DistanceMetric.html" title="Interface for a distance metric.">DistanceMetric</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory in which a prebuilt brute-force index was saved. Files should have been generated by the <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> method of the brute-force <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a brute-force <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance. </dd></dl>

</div>
</div>
<a id="acd94b11fc8a2fade908a509ed2ecfddb" name="acd94b11fc8a2fade908a509ed2ecfddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd94b11fc8a2fade908a509ed2ecfddb">&#9670;&#160;</a></span>load_distance_metric_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1DistanceMetric.html">DistanceMetric</a>&lt; Data_, Distance_ &gt; * knncolle::load_distance_metric_raw </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a distance metric from disk into a <code>Distance</code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the output distance, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory containing a distance metric that was saved to disk by <code><a class="el" href="classknncolle_1_1DistanceMetric.html#aa2989e7df3cb8e65d161629473914d55">DistanceMetric::save()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code>Distance</code> instance, created from the files at <code>dir</code>. If no loading function is available for the saved distance, a <code><a class="el" href="classknncolle_1_1LoadDistanceMetricNotFoundError.html" title="Exception for unknown distance metrics in load_distance_metric_raw().">LoadDistanceMetricNotFoundError</a></code> is thrown. </dd></dl>

</div>
</div>
<a id="ad4af1d9292bd24d4bd3f72f4f99d9cbc" name="ad4af1d9292bd24d4bd3f72f4f99d9cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4af1d9292bd24d4bd3f72f4f99d9cbc">&#9670;&#160;</a></span>load_distance_metric_registry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Distance_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, <a class="el" href="#a67fb4089867eeafca50930f79698f820">LoadDistanceMetricFunction</a>&lt; Data_, Distance_ &gt; &gt; &amp; knncolle::load_distance_metric_registry </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the output distance, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global map where the keys are distance metric names (see <code><a class="el" href="classknncolle_1_1DistanceMetric.html#aa2989e7df3cb8e65d161629473914d55">DistanceMetric::save()</a></code>) and the values are distance loading functions.</dd></dl>
<p>No loading functions are available when the global map is first initialized. Users should call <code><a class="el" href="#a72ca6694c66f6c7107baffb3b8614d2e">register_load_euclidean_distance()</a></code> and/or <code><a class="el" href="#a9e446385ed1746050c0bd2450a8e7298">register_load_manhattan_distance()</a></code> to populate the map with loaders for distances they intend to support. </p>

</div>
</div>
<a id="a54a79aea2d2c0a9ece9e107c60776c22" name="a54a79aea2d2c0a9ece9e107c60776c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a79aea2d2c0a9ece9e107c60776c22">&#9670;&#160;</a></span>load_l2normalized_prebuilt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ , typename Normalized_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; * knncolle::load_l2normalized_prebuilt </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an L2-normalized search index (i.e., a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> created by <code><a class="el" href="classknncolle_1_1L2NormalizedBuilder.html" title="Wrapper around a builder with L2 normalization.">L2NormalizedBuilder</a></code>) from its on-disk representation. This is not provided in the registry by default as its depends on the application's set of the acceptable <code>Normalized_</code> types. The <code>Normalized_</code> type in the saved index can be retrived by <code><a class="el" href="#a7226ddc157c8e3c39d89b13bb412dda4">load_l2normalized_prebuilt_types()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the input and query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point. </td></tr>
    <tr><td class="paramname">Normalized_</td><td>Floating-point type for the L2-normalized data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory in which a prebuilt L2-normalized index was saved. Files should have been generated by the <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> method of the L2-normalized <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an L2-normalized <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance. </dd></dl>

</div>
</div>
<a id="a7226ddc157c8e3c39d89b13bb412dda4" name="a7226ddc157c8e3c39d89b13bb412dda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7226ddc157c8e3c39d89b13bb412dda4">&#9670;&#160;</a></span>load_l2normalized_prebuilt_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structknncolle_1_1L2NormalizedPrebuiltTypes.html">L2NormalizedPrebuiltTypes</a> knncolle::load_l2normalized_prebuilt_types </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory in which a prebuilt L2-normalized index was saved. Files should have been generated by the <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> method of the L2-normalized <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Template types of the saved instance of a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> L2-normalized subclass. This is typically used to choose template parameters for <code><a class="el" href="#a54a79aea2d2c0a9ece9e107c60776c22">load_l2normalized_prebuilt()</a></code>. </dd></dl>

</div>
</div>
<a id="a2157dec9e895be903278fc6903c793e0" name="a2157dec9e895be903278fc6903c793e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2157dec9e895be903278fc6903c793e0">&#9670;&#160;</a></span>load_prebuilt_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; * knncolle::load_prebuilt_raw </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a neighbor search index from disk into a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> object. This should be called with the same template parameters as the <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> interface from which <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> was called. It is expected that <code><a class="el" href="#a2157dec9e895be903278fc6903c793e0">load_prebuilt_raw()</a></code> should create an object that is "equivalent" to the object that was saved with <code>save()</code>, i.e., any neighbor search results should be the same across the original and reloaded <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory containing a prebuilt index that was saved to disk by <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance, created from the files at <code>dir</code>. If no loading function can be found for the search algorithm, a <code><a class="el" href="classknncolle_1_1LoadPrebuiltNotFoundError.html" title="Exception for unknown search algorithms in load_prebuilt_raw().">LoadPrebuiltNotFoundError</a></code> is thrown. </dd></dl>

</div>
</div>
<a id="aa08de1eb1a23d5e13dc11e23ad7967ea" name="aa08de1eb1a23d5e13dc11e23ad7967ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08de1eb1a23d5e13dc11e23ad7967ea">&#9670;&#160;</a></span>load_prebuilt_registry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, <a class="el" href="#a0574e57c9150cb0bfe1da0e7eff6aa01">LoadPrebuiltFunction</a>&lt; Index_, Data_, Distance_ &gt; &gt; &amp; knncolle::load_prebuilt_registry </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global map where the keys are algorithm names (see <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>) and the values are the prebuilt loading functions.</dd></dl>
<p>No loading functions are available when the global is first initialized. Users should call <code>register_load_bruteforce_prebuilt()</code>, <code>register_load_vptree_prebuilt()</code>, etc. to populate the map with loaders for algorithms they intend to support. For L2-normalized indices, a loader function can be defined with <code><a class="el" href="#a54a79aea2d2c0a9ece9e107c60776c22">load_l2normalized_prebuilt()</a></code>. </p>

</div>
</div>
<a id="a0958bf13fd4ad18e0fa0d35d9bd47665" name="a0958bf13fd4ad18e0fa0d35d9bd47665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0958bf13fd4ad18e0fa0d35d9bd47665">&#9670;&#160;</a></span>load_prebuilt_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &gt; knncolle::load_prebuilt_shared </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a neighbor search index from disk into a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> object. This should be called with the same template parameters as the <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> interface from which <code>save()</code> was called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory containing a prebuilt index that was saved to disk by <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance, created from the files at <code>dir</code>. This uses the return value of <code><a class="el" href="#a2157dec9e895be903278fc6903c793e0">load_prebuilt_raw()</a></code>. </dd></dl>

</div>
</div>
<a id="a9cb4f999cb4b25dd5bd4595bfb680f10" name="a9cb4f999cb4b25dd5bd4595bfb680f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4f999cb4b25dd5bd4595bfb680f10">&#9670;&#160;</a></span>load_prebuilt_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; &gt; knncolle::load_prebuilt_unique </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a neighbor search index from disk into a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> object. This should be called with the same template parameters as the <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> interface from which <code>save()</code> was called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory containing a prebuilt index that was saved to disk by <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance, created from the files at <code>dir</code>. This uses the return value of <code><a class="el" href="#a2157dec9e895be903278fc6903c793e0">load_prebuilt_raw()</a></code>. </dd></dl>

</div>
</div>
<a id="a68fe941ede848705fba1c15da9cf772a" name="a68fe941ede848705fba1c15da9cf772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fe941ede848705fba1c15da9cf772a">&#9670;&#160;</a></span>load_vptree_prebuilt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ , class DistanceMetric_  = DistanceMetric&lt;Data_, Distance_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1Prebuilt.html">Prebuilt</a>&lt; Index_, Data_, Distance_ &gt; * knncolle::load_vptree_prebuilt </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a VP-tree search index (i.e., a <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> created by <code><a class="el" href="classknncolle_1_1VptreeBuilder.html" title="Perform a nearest neighbor search based on a vantage point (VP) tree.">VptreeBuilder</a></code>) from its on-disk representation. This is not provided in the registry by default as its depends on the application's choice of <code>DistanceMetric_</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">DistanceMetric_</td><td>Class implementing the distance metric calculation. This should satisfy the <code><a class="el" href="classknncolle_1_1DistanceMetric.html" title="Interface for a distance metric.">DistanceMetric</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Path to a directory in which a prebuilt VP-tree index was saved. Files should have been generated by the <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code> method of the VP-tree <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a VP-tree <code><a class="el" href="classknncolle_1_1Prebuilt.html" title="Interface for prebuilt nearest-neighbor search indices.">Prebuilt</a></code> instance. </dd></dl>

</div>
</div>
<a id="a5faf80c12bbfbab853c41f6d001fe073" name="a5faf80c12bbfbab853c41f6d001fe073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faf80c12bbfbab853c41f6d001fe073">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_ , class Run_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::parallelize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_workers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_</td>          <td class="paramname"><span class="paramname"><em>num_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Run_</td>          <td class="paramname"><span class="paramname"><em>run_task_range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_</td><td>Integer type for the number of tasks. </td></tr>
    <tr><td class="paramname">Run_</td><td>Function to execute a range of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_workers</td><td>Number of workers. </td></tr>
    <tr><td class="paramname">num_tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">run_task_range</td><td>Function to iterate over a range of tasks within a worker.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, this is an alias to <code><a class="elRef" href="https://ltla.github.io/subpar/namespacesubpar.html#a6299ecb1a7d6184a37af21dfe09cc92e">subpar::parallelize_range()</a></code>. However, if the <code>KNNCOLLE_CUSTOM_PARALLEL</code> function-like macro is defined, it is called instead. Any user-defined macro should accept the same arguments as <code><a class="elRef" href="https://ltla.github.io/subpar/namespacesubpar.html#a6299ecb1a7d6184a37af21dfe09cc92e">subpar::parallelize_range()</a></code>. </p>

</div>
</div>
<a id="a1e25b966ec80b5ab45dced14fe690e6b" name="a1e25b966ec80b5ab45dced14fe690e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e25b966ec80b5ab45dced14fe690e6b">&#9670;&#160;</a></span>quick_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Length_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::quick_load </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_ *const</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Length_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an array from a binary file at <code>path</code>. This is intended for developer use in <code>load_prebuilt()</code> functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Type of values to be read. </td></tr>
    <tr><td class="paramname">Length_</td><td>Integer type of the length of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File path to read from. </td></tr>
    <tr><td class="paramname">contents</td><td>Pointer to an array in which to store the contents of <code>path</code>. This should have at least <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements (not bytes) to be read from <code>path</code>. This should be non-negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9191267167f1e0d7201b276c8a9caa2a" name="a9191267167f1e0d7201b276c8a9caa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9191267167f1e0d7201b276c8a9caa2a">&#9670;&#160;</a></span>quick_load_as_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string knncolle::quick_load_as_string </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the contents of a binary file as a string. This is intended for developer use in <code>load_prebuilt()</code> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File path to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of <code>path</code> as a string. </dd></dl>

</div>
</div>
<a id="acf69c31b24c8a2bda72371f64133f8b8" name="acf69c31b24c8a2bda72371f64133f8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf69c31b24c8a2bda72371f64133f8b8">&#9670;&#160;</a></span>quick_save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Length_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::quick_save </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input_ *const</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Length_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves an array to a binary file at <code>path</code>. This is intended for developer use in implementations of <code><a class="el" href="classknncolle_1_1Prebuilt.html#add21dc74e08a6ad495c6e241fa3d5968">Prebuilt::save()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Type of values to be saved. </td></tr>
    <tr><td class="paramname">Length_</td><td>Integer type of the length of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File path to save to. Any directories in the path should already exist. </td></tr>
    <tr><td class="paramname">contents</td><td>Pointer to an array of contents to be saved. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the array, in terms of the number of elements (not the number of bytes). This should be non-negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72ca6694c66f6c7107baffb3b8614d2e" name="a72ca6694c66f6c7107baffb3b8614d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ca6694c66f6c7107baffb3b8614d2e">&#9670;&#160;</a></span>register_load_euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::register_load_euclidean_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a loading function for <code><a class="el" href="classknncolle_1_1EuclideanDistance.html" title="Compute Euclidean distances between two input vectors.">EuclideanDistance</a></code> using <code>euclidean_distance_save_name</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the output distance, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e446385ed1746050c0bd2450a8e7298" name="a9e446385ed1746050c0bd2450a8e7298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e446385ed1746050c0bd2450a8e7298">&#9670;&#160;</a></span>register_load_manhattan_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::register_load_manhattan_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a loading function for <code><a class="el" href="classknncolle_1_1ManhattanDistance.html" title="Compute Manhattan distances between two input vectors.">ManhattanDistance</a></code> using <code>manhattan_distance_save_name</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Numeric type for the output distance, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab42206db56aa02366c741249e609465c" name="ab42206db56aa02366c741249e609465c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42206db56aa02366c741249e609465c">&#9670;&#160;</a></span>report_all_neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::report_all_neighbors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; Distance_, Index_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>all_neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Distance_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>output_distances</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report the indices and distances of all neighbors in range of an observation of interest. It is assumed that the observation of interest is not detected as its own neighbor, presumably as it does not exist in the original input dataset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">all_neighbors</td><td>Vector of (distance, index) pairs for all neighbors within range of the observation of interest. This may include the observation itself. Note that this will be sorted on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Pointer to a vector in which to store the indices of all neighbors in range, sorted by distance. If <code>NULL</code>, the indices will not be reported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_distances</td><td>Pointer to a vector in which to store the (sorted) distances to all neighbors in range. If <code>NULL</code>, the distances will not be reported. Otherwise, on output, this will have the same length as <code>*output_indices</code> and contain distances to each of those neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24a311775039654985b447c85d03782" name="af24a311775039654985b447c85d03782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24a311775039654985b447c85d03782">&#9670;&#160;</a></span>report_all_neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void knncolle::report_all_neighbors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; Distance_, Index_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>all_neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Distance_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>output_distances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>self</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report the indices and distances of all neighbors in range of an observation of interest. If the observation of interest is detected as its own neighbor, it will be removed from the output vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distance_</td><td>Numeric type for the distances, usually floating-point. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">all_neighbors</td><td>Vector of (distance, index) pairs for all neighbors within range of the observation of interest. This may include the observation itself. Note that this will be sorted on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Pointer to a vector in which to store the indices of all neighbors in range, sorted by distance. If <code>NULL</code>, the indices will not be reported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_distances</td><td>Pointer to a vector in which to store the (sorted) distances to all neighbors in range. If <code>NULL</code>, the distances will not be reported. Otherwise, on output, this will have the same length as <code>*output_indices</code> and contain distances to each of those neighbors. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">self</td><td>Index of the observation of interest, i.e., for which neighbors are to be identified. If present in <code>all_neighbors</code>, this will be removed from <code>output_indices</code> and <code>output_distances</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
